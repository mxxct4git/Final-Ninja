1️⃣ Basics & Syntax
Variables & Data Types (int, float, str, bool, list, tuple, dict, set)
Operators (+, -, *, /, //, %, **) & Comparison (==, !=, >, <, >=, <=)
Control Flow (if-elif-else, for & while loops, break & continue)

2️⃣ Functions & Scope
Defining functions (def func_name(args): return result)
Default parameters, *args, **kwargs
Scope: Local vs Global variables (global, nonlocal)

3️⃣ Data Structures & Algorithms
Lists: Indexing, slicing, .append(), .remove(), .sort(), list comprehensions
Tuples: Immutable, unpacking (a, b = (1, 2))
Dictionaries: Key-value pairs, .get(), .keys(), .values(), dictionary comprehensions
Sets: Unique values, set operations (union(), intersection(), difference())
Sorting & Searching: sorted(), sort(), binary search, linear search
Big O Notation: Analyze time complexity (O(1), O(n), O(log n), O(n²))

4️⃣ Object-Oriented Programming (OOP)
Classes & Objects (class Car: def __init__(self, brand):)
Encapsulation (self.__private_var)
Inheritance (class ElectricCar(Car))
Polymorphism & Method Overriding

5️⃣ Error Handling & Debugging
Try-Except (try: x = 1/0 except ZeroDivisionError: print("Error"))
Raising errors (raise ValueError("Invalid input"))
Using assert for debugging

6️⃣ File Handling
Opening & Reading Files (with open("file.txt", "r") as f: print(f.read()))
Writing to Files (with open("file.txt", "w") as f: f.write("Hello"))

7️⃣ Advanced Topics
Recursion: Base case & recursive case
Generators & Iterators (yield, next(), iter())
Lambda Functions: lambda x: x*2
Map, Filter, Reduce (map(func, list), filter(func, list))
Multi-threading (if in scope)

8️⃣ Common Pitfalls & Best Practices
Mutable default arguments (def func(lst=[]):)
Floating-point precision issues (0.1 + 0.2 != 0.3)
Avoid deep copying issues (copy.copy() vs copy.deepcopy())
Write readable & efficient code (PEP8, f-strings)